local mgr = require("mgr") 
local js = require("cjson.safe")

local conn, myconn 
local function clear_all() 
	local r, e = myconn:query("delete from user") 	assert(r, e)
end

local function select_limit(sql_part, count, cb)
	for page = 1, math.hugeint do
		local sql = sql_part .. string.format(" limit %s,%s", (page - 1) * count, count)
		local rs, e = conn:select(sql) 		assert(rs, e)
		if #rs == 0 then break end
		cb(rs)
	end
end

local function sync_all() 
	select_limit("select * from user order by rowid", 1000, function(rs)
		local arr = {}
		for _, r in ipairs(rs) do
			table.insert(arr, string.format("('%s', '%s', '%s')", conn:escape(r.username), conn:escape(r.password), r.active))
		end

		local sql = "replace into user (username, password, active) values " .. table.concat(arr, ",")
		local r, e = myconn:query(sql) 		assert(r, e)
	end)
end

local function sync_set(last_active, total)  
	local rs, e = myconn:query("select max(active) as active, count(*) as count from user") 	assert(rs, e)
	local last_mysql_active, last_mysql_total = rs[1].active, tonumber(rs[1].count)  			assert(total >= last_mysql_total)
	select_limit(string.format("select * from user where active>'%s' order by rowid", last_mysql_active), 1000, function(rs)
		local arr = {}
		for _, r in ipairs(rs) do
			table.insert(arr, string.format("('%s', '%s', '%s')", conn:escape(r.username), conn:escape(r.password), r.active))
		end

		local sql = "replace into user (username, password, active) values " .. table.concat(arr, ",")
		local r, e = myconn:query(sql) 	assert(r, e)
	end)
end

local function sync_del()
	local old, new, del = {}, {}, {}
	local rs, e = myconn:query("select username from user") 	assert(rs, e)
	for _, r in ipairs(rs) do old[r.username] = 1 end

	local rs, e = conn:select("select username from user") 		assert(rs, e)
	for _, r in ipairs(rs) do new[r.username] = 1 end
	for k in pairs(old) do local _ = new[k] or table.insert(del, string.format("'%s'", k)) end

	if #del > 0 then 
		local sql = string.format("delete from user where username in (%s)", table.concat(del, ","))
		local r, e = myconn:query(sql) 							assert(r, e)
	end
end

local function sync_part(action)
	assert(action)
	local rs, e =  conn:select("select max(active) as active, count(*) as count from user") 	assert(rs, e) 
	local active, total, now = rs[1].active, tonumber(rs[1].count), os.date("%Y-%m-%d %H:%M:%S")
	-- active = "2020-06-21 10:54:37"
	if active > now then
		print("invalid system time", active, now, "sync all")
		return sync_all()
	end
	local _ = action.del and sync_del() 		-- 同一次修改中有增删改时，先执行删除的同步
	local _ = (action.add or action.set) and sync_set(active, total)
end

local function sync(action, init)
	if init then 
		-- 程序启动时，清空mysql并同步所有
		local ins = mgr.ins()
		conn, myconn = ins.conn, ins.myconn 	assert(conn and myconn)
		return clear_all(), sync_all()
	end
	return sync_part(action)
end 

return {sync = sync}
